package securitytxt

import (
	"io"
	"strings"
)

// A File represents a security.txt file
type File struct {
	errors   []error
	comments []string

	contact         []string
	encryption      []string
	disclosure      []string
	acknowledgement []string
}

// FromReader returns a new *File, generated by parsing
// the contents of the provided io.Reader, and an error
// if any errors were encountered. More detail can be
// obtained by calling the returned *File's Errors() method
func FromReader(r io.Reader) (*File, error) {
	return parse(r)
}

// addContact adds a new contact string to the File
func (f *File) addContact(c string) {
	f.contact = append(f.contact, c)
}

// Contact returns a slice of contact values from the File
func (f File) Contact() []string {
	return f.contact
}

// PhoneContact returns any contact values that are valid phone numbers
func (f File) PhoneContact() []string {
	out := make([]string, 0)
	for _, c := range f.contact {
		if validPhone(c) {
			out = append(out, c)
		}
	}

	return out
}

// URIContact returns any contact values that are valid URIs
func (f File) URIContact() []string {
	out := make([]string, 0)
	for _, c := range f.contact {
		if validURI(c) {
			out = append(out, c)
		}
	}

	return out
}

// EmailContact returns any contact values that are valid email addresses
func (f File) EmailContact() []string {
	out := make([]string, 0)
	for _, c := range f.contact {
		if validEmail(c) {
			out = append(out, c)
		}
	}

	return out
}

// addEncryption adds an encryption value to the File
func (f *File) addEncryption(e string) {
	f.encryption = append(f.encryption, e)
}

// HasEncryption returns true if there is at least one encryption value
func (f File) HasEncryption() bool {
	return len(f.encryption) > 0
}

// Encryption returns a slice of encryption URIs from the File
func (f File) Encryption() []string {
	return f.encryption
}

// addDisclosure adds a disclosure value to the File
func (f *File) addDisclosure(d string) {
	f.disclosure = append(f.disclosure, d)
}

// HasDisclosure returns true if there is at least one disclosure value
func (f File) HasDisclosure() bool {
	return len(f.disclosure) > 0
}

// HasFullDisclosure returns true if there was a disclosure value of 'full'
func (f File) HasFullDisclosure() bool {
	for _, d := range f.disclosure {
		if strings.ToLower(d) == "full" {
			return true
		}
	}

	return false
}

// HasPartialDisclosure returns true if there was a disclosure value of 'partial'
func (f File) HasPartialDisclosure() bool {
	for _, d := range f.disclosure {
		if strings.ToLower(d) == "partial" {
			return true
		}
	}

	return false
}

// HasNoneDisclosure returns true if there was a disclosure value of 'none'
func (f File) HasNoneDisclosure() bool {
	for _, d := range f.disclosure {
		if strings.ToLower(d) == "none" {
			return true
		}
	}

	return false
}

// Disclosure returns a slice of disclosure URIs from the File
func (f File) Disclosure() []string {
	return f.disclosure
}

// addAcknowledgement adds an acknowledgement value to the FILE
func (f *File) addAcknowledgement(a string) {
	f.acknowledgement = append(f.acknowledgement, a)
}

// HasAcknowledgement returns true if there is at least one acknowledgement value
func (f File) HasAcknowledgement() bool {
	return len(f.acknowledgement) > 0
}

// Acknowledgement returns a slice of acknowledgement values from the File
func (f File) Acknowledgement() []string {
	return f.acknowledgement
}

// addComment adds a comment to the File
func (f *File) addComment(c string) {
	f.comments = append(f.comments, c)
}

// Comments returns a slice of comments from the File
func (f File) Comments() []string {
	return f.comments
}

// addError adds an error value to the File
func (f *File) addError(err error) {
	f.errors = append(f.errors, err)
}

// HasErrors returns true if any errors occured during parsing
func (f File) HasErrors() bool {
	return len(f.errors) > 0
}

// Errors returns a slice of errors encountered during parsing
func (f File) Errors() []error {
	return f.errors
}
