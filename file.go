package securitytxt

import (
	"io"
	"strings"
)

// A File represents a security.txt file
type File struct {
	errors   []error
	comments []string

	fields []Field
}

func (f *File) addField(nf Field) {
	f.fields = append(f.fields, nf)
}

func (f File) Fields(filter string) []Field {
	if filter == "" {
		return f.fields
	}

	out := make([]Field, 0)
	for _, field := range f.fields {
		if strings.ToLower(field.option) == filter {
			out = append(out, field)
		}
	}
	return out
}

// FromReader returns a new *File, generated by parsing
// the contents of the provided io.Reader, and an error
// if any errors were encountered. More detail can be
// obtained by calling the returned *File's Errors() method
func FromReader(r io.Reader) (*File, error) {
	return parse(r)
}

// Contact returns a slice of contact values from the File
func (f File) Contact() []Field {
	return f.Fields(contactField)
}

// PhoneContact returns any contact values that are valid phone numbers
func (f File) PhoneContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validPhone(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// URIContact returns any contact values that are valid URIs
func (f File) URIContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validURI(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// EmailContact returns any contact values that are valid email addresses
func (f File) EmailContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validEmail(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// HasEncryption returns true if there is at least one encryption value
func (f File) HasEncryption() bool {
	return len(f.Encryption()) > 0
}

// Encryption returns a slice of encryption URIs from the File
func (f File) Encryption() []Field {
	return f.Fields(encryptionField)
}

// HasDisclosure returns true if there is at least one disclosure value
func (f File) HasDisclosure() bool {
	return len(f.Disclosure()) > 0
}

// HasFullDisclosure returns true if there was a disclosure value of 'full'
func (f File) HasFullDisclosure() bool {
	for _, d := range f.Disclosure() {
		if strings.ToLower(d.String()) == "full" {
			return true
		}
	}

	return false
}

// HasPartialDisclosure returns true if there was a disclosure value of 'partial'
func (f File) HasPartialDisclosure() bool {
	for _, d := range f.Disclosure() {
		if strings.ToLower(d.String()) == "partial" {
			return true
		}
	}

	return false
}

// HasNoneDisclosure returns true if there was a disclosure value of 'none'
func (f File) HasNoneDisclosure() bool {
	for _, d := range f.Disclosure() {
		if strings.ToLower(d.String()) == "none" {
			return true
		}
	}

	return false
}

// Disclosure returns a slice of disclosure URIs from the File
func (f File) Disclosure() []Field {
	return f.Fields(disclosureField)
}

// HasAcknowledgement returns true if there is at least one acknowledgement value
func (f File) HasAcknowledgement() bool {
	return len(f.Acknowledgement()) > 0
}

// Acknowledgement returns a slice of acknowledgement values from the File
func (f File) Acknowledgement() []Field {
	return f.Fields(acknowledgementField)
}

// addComment adds a comment to the File
func (f *File) addComment(c string) {
	f.comments = append(f.comments, c)
}

// Comments returns a slice of comments from the File
func (f File) Comments() []string {
	return f.comments
}

// addError adds an error value to the File
func (f *File) addError(err error) {
	f.errors = append(f.errors, err)
}

// HasErrors returns true if any errors occured during parsing
func (f File) HasErrors() bool {
	return len(f.errors) > 0
}

// Errors returns a slice of errors encountered during parsing
func (f File) Errors() []error {
	return f.errors
}
