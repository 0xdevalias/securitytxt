package securitytxt

import (
	"bufio"
	"fmt"
	"io"
	"strings"
)

const (
	contactField         = "contact"
	encryptionField      = "encryption"
	disclosureField      = "disclosure"
	acknowledgementField = "acknowledgement"
)

// A File represents a security.txt file
type File struct {
	errors   []error
	comments []string

	contact         []string
	encryption      []string
	disclosure      []string
	acknowledgement []string
}

// FromReader returns a new *File, generated by parsing
// the contents of the provided io.Reader, and an error
// if any errors were encountered. More detail can be
// obtained by calling the returned *File's Errors() method
func FromReader(r io.Reader) (*File, error) {
	f := &File{}
	err := f.parse(r)
	return f, err
}

func (f *File) parse(r io.Reader) error {
	sc := bufio.NewScanner(r)

	n := 0
	for sc.Scan() {
		n++

		line := strings.TrimSpace(sc.Text())

		if line == "" {
			continue
		}

		if line[0] == '#' {
			f.addComment(line)
			continue
		}

		parts := strings.SplitN(line, ":", 2)
		if len(parts) != 2 {
			f.addError(fmt.Errorf("invalid input on line %d: %s", n, line))
			continue
		}

		option := strings.ToLower(parts[0])
		value := strings.TrimSpace(parts[1])

		switch option {

		case contactField:
			if !validContact(value) {
				f.addError(fmt.Errorf("invalid value '%s' for option '%s' on line %d", value, option, n))
				continue
			}
			f.addContact(value)

		case encryptionField:
			if !validURI(value) {
				f.addError(fmt.Errorf("invalid value '%s' for option '%s' on line %d", value, option, n))
				continue
			}
			f.addEncryption(value)

		case disclosureField:
			if !validDisclosure(value) {
				f.addError(fmt.Errorf(
					"invalid value '%s' for option '%s' on line %d, should be one of [full, partial, none]", value, option, n,
				))
				continue
			}
			f.addDisclosure(value)

		case acknowledgementField:
			if !validURI(value) {
				f.addError(fmt.Errorf("invalid value '%s' for option '%s' on line %d", value, option, n))
				continue
			}
			f.addAcknowledgement(value)

		default:
			f.addError(fmt.Errorf("invalid option '%s' on line %d", option, n))
		}

	}

	// No lines were scanned
	if n == 0 {
		f.addError(fmt.Errorf("empty file"))
	}

	if len(f.contact) < 1 {
		f.addError(fmt.Errorf("does not contain at least one contact field"))
	}

	if len(f.errors) > 0 {
		return fmt.Errorf("%d errors encountered during parsing", len(f.errors))
	}

	return nil
}

// addContact adds a new contact string to the File
func (f *File) addContact(c string) {
	f.contact = append(f.contact, c)
}

// Contact returns a slice of contact values from the File
func (f File) Contact() []string {
	return f.contact
}

// addEncryption adds an encryption value to the File
func (f *File) addEncryption(e string) {
	f.encryption = append(f.encryption, e)
}

// Encryption returns a slice of encryption URIs from the File
func (f File) Encryption() []string {
	return f.encryption
}

// addDisclosure adds a disclosure value to the File
func (f *File) addDisclosure(d string) {
	f.disclosure = append(f.disclosure, d)
}

// Disclosure returns a slice of disclosure URIs from the File
func (f File) Disclosure() []string {
	return f.disclosure
}

// addAcknowledgement adds an acknowledgement value to the FILE
func (f *File) addAcknowledgement(a string) {
	f.acknowledgement = append(f.acknowledgement, a)
}

// Acknowledgement returns a slice of acknowledgement values from the File
func (f File) Acknowledgement() []string {
	return f.acknowledgement
}

// addComment adds a comment to the File
func (f *File) addComment(c string) {
	f.comments = append(f.comments, c)
}

// Comments returns a slice of comments from the File
func (f File) Comments() []string {
	return f.comments
}

// addError adds an error value to the File
func (f *File) addError(err error) {
	f.errors = append(f.errors, err)
}

// Errors returns a slice of errors encountered during parsing
func (f File) Errors() []error {
	return f.errors
}
